return {
  "ms-jpq/coq_nvim",
  event = "InsertEnter",
  --lazy = false,
  --branch = "coq",
  cmd = { "COQdeps", "COQsnips" },
  build = ":COQdeps",
  dependencies = {
    { "ms-jpq/coq.artifacts" },
    { "ms-jpq/coq.thirdparty" },
  },
  init = function()
    vim.g.coq_settings = {
      auto_start = "shut-up",
      xdg = true,
      keymap = {
        recommended = false,
        eval_snips = "<c-e>",
        bigger_preview = "<c-w>",
        jump_to_mark = "<c-h>",
        --pre_select = false,
        --manual_complete = ,
        --repeat = ".",
      },
      display = {
        --mark_applied_notify = false,
        statusline = { helo = false },
      },
    }
  end,
  config = function()
    -- we don't want this since we want to use COQ macros etc
    --if vim.b.bigfile then
    --  return
    --end

    local coq = require("coq")
    local map = vim.api.nvim_set_keymap

    require("coq_3p")({
      {
        -- works only if enclosed in `!foo`
        src = "repl",
        sh = "bash",
        shell = { pl = "perl", n = "node", py = "python" },
        max_lines = 100,
        deadline = 2000,
        short_name = "RUNSH",
        unsafe = { "rm", "mv", "poweroff", "reboot", "sudo" },
      },
      {
        src = "figlet",
        short_name = "BIG",
        trigger = "!big",
        fonts = { "/usr/share/figlet/fonts/standard.flf" },
      },
      {
        -- works only after = at end
        src = "bc",
        short_name = "MATH",
        precision = 6,
      },
      { src = "vim_dadbod_completion", short_name = "DB" },
      { src = "vimtex", short_name = "vTEX" },
      { src = "nvimlua", short_name = "nLUA", conf_only = true },
      { src = "dap" },
      { src = "builtin/ada" },
      { src = "builtin/c" },
      { src = "builtin/clojure" },
      { src = "builtin/css" },
      { src = "builtin/haskell" },
      { src = "builtin/html" },
      { src = "builtin/js" },
      { src = "builtin/php" },
      { src = "builtin/syntax" },
      { src = "builtin/xml" },
    })

    map("i", "<tab>", [[pumvisible() ? "<Down>" : "<tab>"]], { expr = true, noremap = true })
    map("i", "<s-tab>", [[pumvisible() ? "<Up>" : "<bs>"]], { expr = true, noremap = true })
    map(
      "i",
      "<cr>",
      [[pumvisible() ? (complete_info().selected != -1 ? "<c-y>" : "<c-k><esc><cr>") : "<c-k><esc><cr>"]],
      { expr = true, noremap = true }
    )

    -- TODO: we don't need this if coq ever implements what blink.cmp does
    local keys = "?!@#$%^&*+-=`\"',./\\:;<>()[]{} "
    for i = 1, #keys do
      local keymap = keys:sub(i, i)
      local key = keymap
      if key == "\\" then
        key = "\\\\"
      elseif key == '"' then
        key = '\\"'
      end

      local pumstring = string.format('(pumvisible() && complete_info().selected != -1) ? "<c-y>%s"  : "%s"', key, key)
      map("i", keymap, pumstring, { expr = true, noremap = true })
    end

    -- autopair + COQ setup
    --local npairs = require('nvim-autopairs')
    --
    --npairs.setup({
    --  disable_in_macro = true,
    --  disable_in_visualblock = true,
    --  check_ts = true,
    --  fast_wrap = {
    --    map = '<C-e>',
    --  },
    --  map_bs = false,
    --  map_cr = false,
    --})
    --
    ---- skip it, if you use another global object
    --_G.MUtils = {}
    --
    --MUtils.CR = function()
    --  if vim.fn.pumvisible() ~= 0 then
    --    if vim.fn.complete_info({ 'selected' }).selected ~= -1 then
    --      return npairs.esc('<c-y>')
    --    else
    --      return npairs.esc('<c-e>') .. npairs.autopairs_cr()
    --    end
    --  else
    --    return npairs.autopairs_cr()
    --  end
    --end
    --map('i', '<cr>', 'v:lua.MUtils.CR()', { expr = true, noremap = true })
    --
    --MUtils.BS = function()
    --  if vim.fn.pumvisible() ~= 0 and vim.fn.complete_info({ 'mode' }).mode == 'eval' then
    --    return npairs.esc('<c-e>') .. npairs.autopairs_bs()
    --  else
    --    return npairs.autopairs_bs()
    --  end
    --end
    --map('i', '<bs>', 'v:lua.MUtils.BS()', { expr = true, noremap = true })
  end,
}
